// DO NOT MODIFY!
// Generated by mb-ormapper generator ver 2.3
// https://github.com/tmurakam/mb-ormapper

import Foundation

class AssetBase : ORRecord {

    var name : String = ""
    var type : Int = 0
    var initialBalance : Double = 0
    var sorder : Int = 0
    var identifier : String = ""

    override init() {
        super.init()
    }

    /**
     @brief Migrate database table
     @return YES - table was newly created, NO - table already exists
     */
    class func migrate() -> Bool {
        let columnTypes: [String] = [
            "name", "TEXT",
            "type", "INTEGER",
            "initialBalance", "REAL",
            "sorder", "INTEGER",
            "identifier", "TEXT",
        ]

        return super.migrate(columnTypes, primaryKey:"key")
    }

    // MARK: -  Read operations

    /**
      @brief get the record matchs the id
      @param pid Primary key of the record
      @return record
    */
    class func find(pid: Int) -> Asset? {
        let db = Database.instance()

        let stmt = db.prepare("SELECT * FROM Assets WHERE key = ?;")
        stmt.bindInt(0, val: pid)

        return find_first_stmt(stmt)
    }

    /**
      finder with name

      @param key Key value
      @param cond Conditions (ORDER BY etc)
      @note If you specify WHERE conditions, you must start cond with "AND" keyword.
    */
    class func find_by_name(key: String, cond: String?) -> Asset? {
        let cond2 = cond ?? ""
        let whr = "WHERE name = ? \(cond2) LIMIT 1"
        let stmt = gen_stmt(whr)
        stmt.bindString(0, val:key)
        return find_first_stmt(stmt)
    }

    class func find_by_name(key: String) -> Asset? {
        return find_by_name(key, cond:nil)
    }

    /**
      finder with type

      @param key Key value
      @param cond Conditions (ORDER BY etc)
      @note If you specify WHERE conditions, you must start cond with "AND" keyword.
    */
    class func find_by_type(key: Int, cond: String?) -> Asset? {
        let cond2 = cond ?? ""
        let whr = "WHERE type = ? \(cond2) LIMIT 1"
        let stmt = gen_stmt(whr)
        stmt.bindInt(0, val:key)
        return find_first_stmt(stmt)
    }

    class func find_by_type(key: Int) -> Asset? {
        return find_by_type(key, cond:nil)
    }

    /**
      finder with initialBalance

      @param key Key value
      @param cond Conditions (ORDER BY etc)
      @note If you specify WHERE conditions, you must start cond with "AND" keyword.
    */
    class func find_by_initialBalance(key: Double, cond: String?) -> Asset? {
        let cond2 = cond ?? ""
        let whr = "WHERE initialBalance = ? \(cond2) LIMIT 1"
        let stmt = gen_stmt(whr)
        stmt.bindDouble(0, val:key)
        return find_first_stmt(stmt)
    }

    class func find_by_initialBalance(key: Double) -> Asset? {
        return find_by_initialBalance(key, cond:nil)
    }

    /**
      finder with sorder

      @param key Key value
      @param cond Conditions (ORDER BY etc)
      @note If you specify WHERE conditions, you must start cond with "AND" keyword.
    */
    class func find_by_sorder(key: Int, cond: String?) -> Asset? {
        let cond2 = cond ?? ""
        let whr = "WHERE sorder = ? \(cond2) LIMIT 1"
        let stmt = gen_stmt(whr)
        stmt.bindInt(0, val:key)
        return find_first_stmt(stmt)
    }

    class func find_by_sorder(key: Int) -> Asset? {
        return find_by_sorder(key, cond:nil)
    }

    /**
      finder with identifier

      @param key Key value
      @param cond Conditions (ORDER BY etc)
      @note If you specify WHERE conditions, you must start cond with "AND" keyword.
    */
    class func find_by_identifier(key: String, cond: String?) -> Asset? {
        let cond2 = cond ?? ""
        let whr = "WHERE identifier = ? \(cond2) LIMIT 1"
        let stmt = gen_stmt(whr)
        stmt.bindString(0, val:key)
        return find_first_stmt(stmt)
    }

    class func find_by_identifier(key: String) -> Asset? {
        return find_by_identifier(key, cond:nil)
    }


    /**
      Get first record matches the conditions
      @param cond Conditions (WHERE phrase and so on)
      @return array of records
    */
    class func find_first(cond: String?) -> Asset? {
        let cond2: String
        if (cond == nil) {
            cond2 = "LIMIT 1"
        } else {
            cond2 = cond! + " LIMIT 1"
        }
        let stmt = gen_stmt(cond2)
        return  find_first_stmt(stmt)
    }

    /**
      Get all records match the conditions
      @param cond Conditions (WHERE phrase and so on)
      @return array of records
    */
    class func find_all(cond: String?) -> [Asset] {
        let stmt = gen_stmt(cond)
        return find_all_stmt(stmt)
    }

    /**
      create dbstmt
      @param s condition
      @return dbstmt
    */
    class func gen_stmt(cond: String?) -> dbstmt {
        let sql: String
        if (cond == nil) {
            sql = "SELECT * FROM Assets;"
        } else {
            sql = "SELECT * FROM Assets \(cond!);"
        }  
        let stmt = Database.instance().prepare(sql)
        return stmt
    }

    /**
      Get first record matches the conditions
      @param stmt Statement
      @return array of records
    */
    class func find_first_stmt(stmt: dbstmt) -> Asset? {
        if (stmt.step() == numericCast(SQLITE_ROW)) {
            // e = [[self class] new]
            let e = Asset()
            e._loadRow(stmt)
            return e
        }
        return nil;
    }

    /**
      Get all records match the conditions
      @param stmt Statement
      @return array of records
    */
    class func find_all_stmt(stmt: dbstmt) -> [Asset] {
        var array : [Asset] = []

        while (stmt.step() == numericCast(SQLITE_ROW)) {
            //let e = self.class().new()
            let e = Asset()
            e._loadRow(stmt)
            array.append(e)
        }
        return array;
    }

    override func _loadRow(stmt: dbstmt) {
        self.pid = stmt.colInt(0)
        self.name = stmt.colString(1)
        self.type = stmt.colInt(2)
        self.initialBalance = stmt.colDouble(3)
        self.sorder = stmt.colInt(4)
        self.identifier = stmt.colString(5)
    }

    // MARK: - Create operations

    override func _insert() {
        super._insert()

        let db = Database.instance()
    
        //db.beginTransaction()
        let stmt = db.prepare("INSERT INTO Assets VALUES(NULL,?,?,?,?,?);")
        stmt.bindString(0, val:self.name)
        stmt.bindInt(1, val:self.type)
        stmt.bindDouble(2, val:self.initialBalance)
        stmt.bindInt(3, val:self.sorder)
        stmt.bindString(4, val:self.identifier)
        stmt.step()

        self.pid = db.lastInsertRowId

        //db.commitTransaction()

        db.setModified()
    }

    // MARK: - Update operations

    override func _update() {
        super._update()

        let db = Database.instance()
        //db.beginTransaction()

        let stmt = db.prepare("UPDATE Assets SET "
        + "name = ?"
        + ",type = ?"
        + ",initialBalance = ?"
        + ",sorder = ?"
        + ",identifier = ?"
        + " WHERE key = ?;")
        stmt.bindString(0, val:self.name)
        stmt.bindInt(1, val:self.type)
        stmt.bindDouble(2, val:self.initialBalance)
        stmt.bindInt(3, val:self.sorder)
        stmt.bindString(4, val:self.identifier)
        stmt.bindInt(5, val:self.pid)

        stmt.step()
        //db.commitTransaction()

        db.setModified()
    }

    // MARK: - Delete operations

    /**
      Delete record
    */
    override func delete() {
        let db = Database.instance()

        let stmt = db.prepare("DELETE FROM Assets WHERE key = ?;")
        stmt.bindInt(0, val:self.pid)
        stmt.step()

        db.setModified()
    }

    /**
     Delete all records
    */
    class func delete_cond(cond: String?) {
        let db = Database.instance()

        let cond2: String
        if (cond == nil) {
            cond2 = ""
        } else {
            cond2 = cond!
        }
        let sql = "DELETE FROM Assets \(cond2);"
        db.exec(sql)

        db.setModified()
    }

    override class func delete_all() {
        AssetBase.delete_cond(nil)
    }

    /**
     * get table sql
     */
    class func getTableSql(s: NSMutableString) {
        s.appendString("DROP TABLE Assets;\n")
        s.appendString("CREATE TABLE Assets (key INTEGER PRIMARY KEY")

        s.appendString(", name TEXT")
        s.appendString(", type INTEGER")
        s.appendString(", initialBalance REAL")
        s.appendString(", sorder INTEGER")
        s.appendString(", identifier TEXT")
    
        s.appendString(");\n")

        let ary = find_all(nil)
        for e in ary {
            e.getInsertSql(s)
            s.appendString("\n")
        }
    }

    /**
     * get "INSERT" SQL
     */
    func getInsertSql(s: NSMutableString) {
        s.appendFormat("INSERT INTO Assets VALUES(%ld", self.pid)
        s.appendString(",")
        s.appendString(quoteSqlString(name))
        s.appendString(",")
        s.appendString(quoteSqlString(type.description))
        s.appendString(",")
        s.appendString(quoteSqlString(initialBalance.description))
        s.appendString(",")
        s.appendString(quoteSqlString(sorder.description))
        s.appendString(",")
        s.appendString(quoteSqlString(identifier))
        s.appendString(");")
    }

    // MARK: - Internal functions

    override class func tableName() -> String {
        return "Assets"
    }
}
