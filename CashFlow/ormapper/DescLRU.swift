// DO NOT MODIFY!
// Generated by mb-ormapper generator ver 2.3
// https://github.com/tmurakam/mb-ormapper

import Foundation

class DescLRU : ORRecord {

    var desc : String = ""
    var lastUse : NSDate = NSDate(timeIntervalSince1970: 0)
    var category : Int = 0

    override init() {
        super.init()
    }

    /**
     @brief Migrate database table
     @return YES - table was newly created, NO - table already exists
     */
    class func migrate() -> Bool {
        let columnTypes: [String] = [
            "description", "TEXT",
            "lastUse", "DATE",
            "category", "INTEGER",
        ]

        return super.migrate(columnTypes, primaryKey:"key")
    }

    // MARK: -  Read operations

    /**
      @brief get the record matchs the id
      @param pid Primary key of the record
      @return record
    */
    class func find(pid: Int) -> DescLRU? {
        let db = Database.instance()

        let stmt = db.prepare("SELECT * FROM DescLRUs WHERE key = ?;")
        stmt.bindInt(0, val: pid)

        return find_first_stmt(stmt)
    }

    /**
      finder with description

      @param key Key value
      @param cond Conditions (ORDER BY etc)
      @note If you specify WHERE conditions, you must start cond with "AND" keyword.
    */
    class func find_by_description(key: String, cond: String?) -> DescLRU? {
        let cond2 = cond ?? ""
        let whr = "WHERE description = ? \(cond2) LIMIT 1"
        let stmt = gen_stmt(whr)
        stmt.bindString(0, val:key)
        return find_first_stmt(stmt)
    }

    class func find_by_description(key: String) -> DescLRU? {
        return find_by_description(key, cond:nil)
    }

    /**
      finder with lastUse

      @param key Key value
      @param cond Conditions (ORDER BY etc)
      @note If you specify WHERE conditions, you must start cond with "AND" keyword.
    */
    class func find_by_lastUse(key: NSDate, cond: String?) -> DescLRU? {
        let cond2 = cond ?? ""
        let whr = "WHERE lastUse = ? \(cond2) LIMIT 1"
        let stmt = gen_stmt(whr)
        stmt.bindDate(0, val:key)
        return find_first_stmt(stmt)
    }

    class func find_by_lastUse(key: NSDate) -> DescLRU? {
        return find_by_lastUse(key, cond:nil)
    }

    /**
      finder with category

      @param key Key value
      @param cond Conditions (ORDER BY etc)
      @note If you specify WHERE conditions, you must start cond with "AND" keyword.
    */
    class func find_by_category(key: Int, cond: String?) -> DescLRU? {
        let cond2 = cond ?? ""
        let whr = "WHERE category = ? \(cond2) LIMIT 1"
        let stmt = gen_stmt(whr)
        stmt.bindInt(0, val:key)
        return find_first_stmt(stmt)
    }

    class func find_by_category(key: Int) -> DescLRU? {
        return find_by_category(key, cond:nil)
    }


    /**
      Get first record matches the conditions
      @param cond Conditions (WHERE phrase and so on)
      @return array of records
    */
    class func find_first(cond: String?) -> DescLRU? {
        let cond2: String
        if (cond == nil) {
            cond2 = "LIMIT 1"
        } else {
            cond2 = cond! + " LIMIT 1"
        }
        let stmt = gen_stmt(cond2)
        return  find_first_stmt(stmt)
    }

    /**
      Get all records match the conditions
      @param cond Conditions (WHERE phrase and so on)
      @return array of records
    */
    class func find_all(cond: String?) -> [DescLRU] {
        let stmt = gen_stmt(cond)
        return find_all_stmt(stmt)
    }

    /**
      create dbstmt
      @param s condition
      @return dbstmt
    */
    class func gen_stmt(cond: String?) -> dbstmt {
        let sql: String
        if (cond == nil) {
            sql = "SELECT * FROM DescLRUs;"
        } else {
            sql = "SELECT * FROM DescLRUs \(cond!);"
        }  
        let stmt = Database.instance().prepare(sql)
        return stmt
    }

    /**
      Get first record matches the conditions
      @param stmt Statement
      @return array of records
    */
    class func find_first_stmt(stmt: dbstmt) -> DescLRU? {
        if (stmt.step() == numericCast(SQLITE_ROW)) {
            // e = [[self class] new]
            let e = DescLRU()
            e._loadRow(stmt)
            return e
        }
        return nil;
    }

    /**
      Get all records match the conditions
      @param stmt Statement
      @return array of records
    */
    class func find_all_stmt(stmt: dbstmt) -> [DescLRU] {
        var array : [DescLRU] = []

        while (stmt.step() == numericCast(SQLITE_ROW)) {
            //let e = self.class().new()
            let e = DescLRU()
            e._loadRow(stmt)
            array.append(e)
        }
        return array;
    }

    override func _loadRow(stmt: dbstmt) {
        self.pid = stmt.colInt(0)
        self.desc = stmt.colString(1)
        self.lastUse = stmt.colDate(2)
        self.category = stmt.colInt(3)
    }

    // MARK: - Create operations

    override func _insert() {
        super._insert()

        let db = Database.instance()
    
        //db.beginTransaction()
        let stmt = db.prepare("INSERT INTO DescLRUs VALUES(NULL,?,?,?);")
        stmt.bindString(0, val:self.desc)
        stmt.bindDate(1, val:self.lastUse)
        stmt.bindInt(2, val:self.category)
        stmt.step()

        self.pid = db.lastInsertRowId

        //db.commitTransaction()

        db.setModified()
    }

    // MARK: - Update operations

    override func _update() {
        super._update()

        let db = Database.instance()
        //db.beginTransaction()

        let stmt = db.prepare("UPDATE DescLRUs SET "
        + "description = ?"
        + ",lastUse = ?"
        + ",category = ?"
        + " WHERE key = ?;")
        stmt.bindString(0, val:self.desc)
        stmt.bindDate(1, val:self.lastUse)
        stmt.bindInt(2, val:self.category)
        stmt.bindInt(3, val:self.pid)

        stmt.step()
        //db.commitTransaction()

        db.setModified()
    }

    // MARK: - Delete operations

    /**
      Delete record
    */
    override func delete() {
        let db = Database.instance()

        let stmt = db.prepare("DELETE FROM DescLRUs WHERE key = ?;")
        stmt.bindInt(0, val:self.pid)
        stmt.step()

        db.setModified()
    }

    /**
     Delete all records
    */
    class func delete_cond(cond: String?) {
        let db = Database.instance()

        let cond2: String
        if (cond == nil) {
            cond2 = ""
        } else {
            cond2 = cond!
        }
        let sql = "DELETE FROM DescLRUs \(cond2);"
        db.exec(sql)

        db.setModified()
    }

    override class func delete_all() {
        DescLRU.delete_cond(nil)
    }

    /**
     * get table sql
     */
    class func getTableSql(s: NSMutableString) {
        s.appendString("DROP TABLE DescLRUs;\n")
        s.appendString("CREATE TABLE DescLRUs (key INTEGER PRIMARY KEY")

        s.appendString(", description TEXT")
        s.appendString(", lastUse DATE")
        s.appendString(", category INTEGER")
    
        s.appendString(");\n")

        let ary = find_all(nil)
        for e in ary {
            e.getInsertSql(s)
            s.appendString("\n")
        }
    }

    /**
     * get "INSERT" SQL
     */
    func getInsertSql(s: NSMutableString) {
        s.appendFormat("INSERT INTO DescLRUs VALUES(%ld", self.pid)
        s.appendString(",")
        s.appendString(quoteSqlString(desc))
        s.appendString(",")
        s.appendString(quoteSqlString(Database.instance().stringFromDate(lastUse)))
        s.appendString(",")
        s.appendString(quoteSqlString(category.description))
        s.appendString(");")
    }

    // MARK: - Internal functions

    override class func tableName() -> String {
        return "DescLRUs"
    }
}
