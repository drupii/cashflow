// DO NOT MODIFY!
// Generated by mb-ormapper generator ver 2.2
// https://github.com/tmurakam/mb-ormapper

#import "Database.h"
#import "TransactionBase.h"

@interface TransactionBase ()

- (void)_insert;
- (void)_update;
+ (NSString *)tableName;
- (void)_loadRow:(dbstmt *)stmt;
@end

@implementation TransactionBase

- (instancetype)init
{
    self = [super init];
    return self;
}

/**
  @brief Migrate database table

  @return YES - table was newly created, NO - table already exists
*/

+ (BOOL)migrate
{
    NSArray *columnTypes = @[
        @"asset", @"INTEGER",
        @"dst_asset", @"INTEGER",
        @"date", @"DATE",
        @"type", @"INTEGER",
        @"category", @"INTEGER",
        @"value", @"REAL",
        @"description", @"TEXT",
        @"memo", @"TEXT",
        @"identifier", @"TEXT",
        ];

    return [super migrate:columnTypes primaryKey:@"key"];
}

#pragma mark Read operations

/**
  @brief get the record matchs the id

  @param pid Primary key of the record
  @return record
*/
+ (nullable Transaction *)find:(NSInteger)pid
{
    Database *db = [Database instance];

    dbstmt *stmt = [db prepare:@"SELECT * FROM Transactions WHERE key = ?;"];
    [stmt bindInt:0 val:pid];

    return [self find_first_stmt:stmt];
}

/**
  finder with asset

  @param key Key value
  @param cond Conditions (ORDER BY etc)
  @note If you specify WHERE conditions, you must start cond with "AND" keyword.
*/
+ (nullable Transaction*)find_by_asset:(NSInteger)key cond:(nullable NSString *)cond
{
    if (cond == nil) {
        cond = @"WHERE asset = ? LIMIT 1";
    } else {
        cond = [NSString stringWithFormat:@"WHERE asset = ? %@ LIMIT 1", cond];
    }
    dbstmt *stmt = [self gen_stmt:cond];
    [stmt bindInt:0 val:key];
    return [self find_first_stmt:stmt];
}

+ (nullable Transaction*)find_by_asset:(NSInteger)key
{
    return [self find_by_asset:key cond:nil];
}

/**
  finder with dst_asset

  @param key Key value
  @param cond Conditions (ORDER BY etc)
  @note If you specify WHERE conditions, you must start cond with "AND" keyword.
*/
+ (nullable Transaction*)find_by_dst_asset:(NSInteger)key cond:(nullable NSString *)cond
{
    if (cond == nil) {
        cond = @"WHERE dst_asset = ? LIMIT 1";
    } else {
        cond = [NSString stringWithFormat:@"WHERE dst_asset = ? %@ LIMIT 1", cond];
    }
    dbstmt *stmt = [self gen_stmt:cond];
    [stmt bindInt:0 val:key];
    return [self find_first_stmt:stmt];
}

+ (nullable Transaction*)find_by_dst_asset:(NSInteger)key
{
    return [self find_by_dst_asset:key cond:nil];
}

/**
  finder with date

  @param key Key value
  @param cond Conditions (ORDER BY etc)
  @note If you specify WHERE conditions, you must start cond with "AND" keyword.
*/
+ (nullable Transaction*)find_by_date:(NSDate*)key cond:(nullable NSString *)cond
{
    if (cond == nil) {
        cond = @"WHERE date = ? LIMIT 1";
    } else {
        cond = [NSString stringWithFormat:@"WHERE date = ? %@ LIMIT 1", cond];
    }
    dbstmt *stmt = [self gen_stmt:cond];
    [stmt bindDate:0 val:key];
    return [self find_first_stmt:stmt];
}

+ (nullable Transaction*)find_by_date:(NSDate*)key
{
    return [self find_by_date:key cond:nil];
}

/**
  finder with type

  @param key Key value
  @param cond Conditions (ORDER BY etc)
  @note If you specify WHERE conditions, you must start cond with "AND" keyword.
*/
+ (nullable Transaction*)find_by_type:(NSInteger)key cond:(nullable NSString *)cond
{
    if (cond == nil) {
        cond = @"WHERE type = ? LIMIT 1";
    } else {
        cond = [NSString stringWithFormat:@"WHERE type = ? %@ LIMIT 1", cond];
    }
    dbstmt *stmt = [self gen_stmt:cond];
    [stmt bindInt:0 val:key];
    return [self find_first_stmt:stmt];
}

+ (nullable Transaction*)find_by_type:(NSInteger)key
{
    return [self find_by_type:key cond:nil];
}

/**
  finder with category

  @param key Key value
  @param cond Conditions (ORDER BY etc)
  @note If you specify WHERE conditions, you must start cond with "AND" keyword.
*/
+ (nullable Transaction*)find_by_category:(NSInteger)key cond:(nullable NSString *)cond
{
    if (cond == nil) {
        cond = @"WHERE category = ? LIMIT 1";
    } else {
        cond = [NSString stringWithFormat:@"WHERE category = ? %@ LIMIT 1", cond];
    }
    dbstmt *stmt = [self gen_stmt:cond];
    [stmt bindInt:0 val:key];
    return [self find_first_stmt:stmt];
}

+ (nullable Transaction*)find_by_category:(NSInteger)key
{
    return [self find_by_category:key cond:nil];
}

/**
  finder with value

  @param key Key value
  @param cond Conditions (ORDER BY etc)
  @note If you specify WHERE conditions, you must start cond with "AND" keyword.
*/
+ (nullable Transaction*)find_by_value:(double)key cond:(nullable NSString *)cond
{
    if (cond == nil) {
        cond = @"WHERE value = ? LIMIT 1";
    } else {
        cond = [NSString stringWithFormat:@"WHERE value = ? %@ LIMIT 1", cond];
    }
    dbstmt *stmt = [self gen_stmt:cond];
    [stmt bindDouble:0 val:key];
    return [self find_first_stmt:stmt];
}

+ (nullable Transaction*)find_by_value:(double)key
{
    return [self find_by_value:key cond:nil];
}

/**
  finder with description

  @param key Key value
  @param cond Conditions (ORDER BY etc)
  @note If you specify WHERE conditions, you must start cond with "AND" keyword.
*/
+ (nullable Transaction*)find_by_description:(NSString*)key cond:(nullable NSString *)cond
{
    if (cond == nil) {
        cond = @"WHERE description = ? LIMIT 1";
    } else {
        cond = [NSString stringWithFormat:@"WHERE description = ? %@ LIMIT 1", cond];
    }
    dbstmt *stmt = [self gen_stmt:cond];
    [stmt bindString:0 val:key];
    return [self find_first_stmt:stmt];
}

+ (nullable Transaction*)find_by_description:(NSString*)key
{
    return [self find_by_description:key cond:nil];
}

/**
  finder with memo

  @param key Key value
  @param cond Conditions (ORDER BY etc)
  @note If you specify WHERE conditions, you must start cond with "AND" keyword.
*/
+ (nullable Transaction*)find_by_memo:(NSString*)key cond:(nullable NSString *)cond
{
    if (cond == nil) {
        cond = @"WHERE memo = ? LIMIT 1";
    } else {
        cond = [NSString stringWithFormat:@"WHERE memo = ? %@ LIMIT 1", cond];
    }
    dbstmt *stmt = [self gen_stmt:cond];
    [stmt bindString:0 val:key];
    return [self find_first_stmt:stmt];
}

+ (nullable Transaction*)find_by_memo:(NSString*)key
{
    return [self find_by_memo:key cond:nil];
}

/**
  finder with identifier

  @param key Key value
  @param cond Conditions (ORDER BY etc)
  @note If you specify WHERE conditions, you must start cond with "AND" keyword.
*/
+ (nullable Transaction*)find_by_identifier:(NSString*)key cond:(nullable NSString *)cond
{
    if (cond == nil) {
        cond = @"WHERE identifier = ? LIMIT 1";
    } else {
        cond = [NSString stringWithFormat:@"WHERE identifier = ? %@ LIMIT 1", cond];
    }
    dbstmt *stmt = [self gen_stmt:cond];
    [stmt bindString:0 val:key];
    return [self find_first_stmt:stmt];
}

+ (nullable Transaction*)find_by_identifier:(NSString*)key
{
    return [self find_by_identifier:key cond:nil];
}


/**
  Get first record matches the conditions

  @param cond Conditions (WHERE phrase and so on)
  @return array of records
*/
+ (nullable Transaction *)find_first:(NSString *)cond
{
    if (cond == nil) {
        cond = @"LIMIT 1";
    } else {
        cond = [cond stringByAppendingString:@" LIMIT 1"];
    }
    dbstmt *stmt = [self gen_stmt:cond];
    return  [self find_first_stmt:stmt];
}

/**
  Get all records match the conditions

  @param cond Conditions (WHERE phrase and so on)
  @return array of records
*/
+ (nonnull NSMutableArray *)find_all:(NSString *)cond
{
    dbstmt *stmt = [self gen_stmt:cond];
    return  [self find_all_stmt:stmt];
}

/**
  @brief create dbstmt

  @param s condition
  @return dbstmt
*/
+ (nonnull dbstmt *)gen_stmt:(nullable NSString *)cond
{
    NSString *sql;
    if (cond == nil) {
        sql = @"SELECT * FROM Transactions;";
    } else {
        sql = [NSString stringWithFormat:@"SELECT * FROM Transactions %@;", cond];
    }  
    dbstmt *stmt = [[Database instance] prepare:sql];
    return stmt;
}

/**
  Get first record matches the conditions

  @param stmt Statement
  @return array of records
*/
+ (nullable Transaction *)find_first_stmt:(nonnull dbstmt *)stmt
{
    if ([stmt step] == SQLITE_ROW) {
        TransactionBase *e = [[self class] new];
        [e _loadRow:stmt];
        return (Transaction *)e;
    }
    return nil;
}

/**
  Get all records match the conditions

  @param stmt Statement
  @return array of records
*/
+ (nonnull NSMutableArray *)find_all_stmt:(nonnull dbstmt *)stmt
{
    NSMutableArray *array = [NSMutableArray new];

    while ([stmt step] == SQLITE_ROW) {
        TransactionBase *e = [[self class] new];
        [e _loadRow:stmt];
        [array addObject:e];
    }
    return array;
}

- (void)_loadRow:(nonnull dbstmt *)stmt
{
    self.pid = [stmt colInt:0];
    self.asset = [stmt colInt:1];
    self.dstAsset = [stmt colInt:2];
    self.date = [stmt colDate:3];
    self.type = [stmt colInt:4];
    self.category = [stmt colInt:5];
    self.value = [stmt colDouble:6];
    self.desc = [stmt colString:7];
    self.memo = [stmt colString:8];
    self.identifier = [stmt colString:9];
}

#pragma mark Create operations

- (void)_insert
{
    [super _insert];

    Database *db = [Database instance];
    dbstmt *stmt;
    
    //[db beginTransaction];
    stmt = [db prepare:@"INSERT INTO Transactions VALUES(NULL,?,?,?,?,?,?,?,?,?);"];
    [stmt bindInt:0 val:_asset];
    [stmt bindInt:1 val:_dstAsset];
    [stmt bindDate:2 val:_date];
    [stmt bindInt:3 val:_type];
    [stmt bindInt:4 val:_category];
    [stmt bindDouble:5 val:_value];
    [stmt bindString:6 val:_desc];
    [stmt bindString:7 val:_memo];
    [stmt bindString:8 val:_identifier];
    [stmt step];

    self.pid = [db lastInsertRowId];

    //[db commitTransaction];

    [[Database instance] setModified];
}

#pragma mark Update operations

- (void)_update
{
    [super _update];

    Database *db = [Database instance];
    //[db beginTransaction];

    dbstmt *stmt = [db prepare:@"UPDATE Transactions SET "
        "asset = ?"
        ",dst_asset = ?"
        ",date = ?"
        ",type = ?"
        ",category = ?"
        ",value = ?"
        ",description = ?"
        ",memo = ?"
        ",identifier = ?"
        " WHERE key = ?;"];
    [stmt bindInt:0 val:_asset];
    [stmt bindInt:1 val:_dstAsset];
    [stmt bindDate:2 val:_date];
    [stmt bindInt:3 val:_type];
    [stmt bindInt:4 val:_category];
    [stmt bindDouble:5 val:_value];
    [stmt bindString:6 val:_desc];
    [stmt bindString:7 val:_memo];
    [stmt bindString:8 val:_identifier];
    [stmt bindInt:9 val:self.pid];

    [stmt step];
    //[db commitTransaction];

    [[Database instance] setModified];
}

#pragma mark Delete operations

/**
  @brief Delete record
*/
- (void)delete
{
    Database *db = [Database instance];

    dbstmt *stmt = [db prepare:@"DELETE FROM Transactions WHERE key = ?;"];
    [stmt bindInt:0 val:self.pid];
    [stmt step];

    [[Database instance] setModified];
}

/**
  @brief Delete all records
*/
+ (void)delete_cond:(nullable NSString *)cond
{
    Database *db = [Database instance];

    if (cond == nil) {
        cond = @"";
    }
    NSString *sql = [NSString stringWithFormat:@"DELETE FROM Transactions %@;", cond];
    [db exec:sql];

    [[Database instance] setModified];
}

+ (void)delete_all
{
    [TransactionBase delete_cond:nil];
}

/**
 * get table sql
 */
+ (void)getTableSql:(nonnull NSMutableString *)s
{
    [s appendString:@"DROP TABLE Transactions;\n"];
    [s appendString:@"CREATE TABLE Transactions (key INTEGER PRIMARY KEY"];

    [s appendFormat:@", asset INTEGER"];
    [s appendFormat:@", dst_asset INTEGER"];
    [s appendFormat:@", date DATE"];
    [s appendFormat:@", type INTEGER"];
    [s appendFormat:@", category INTEGER"];
    [s appendFormat:@", value REAL"];
    [s appendFormat:@", description TEXT"];
    [s appendFormat:@", memo TEXT"];
    [s appendFormat:@", identifier TEXT"];
    
    [s appendString:@");\n"];

    NSMutableArray *ary = [self find_all:nil];
    for (TransactionBase *e in ary) {
        [e getInsertSql:s];
        [s appendString:@"\n"];
    }
}

/**
 * get "INSERT" SQL
 */
- (void)getInsertSql:(nonnull NSMutableString *)s
{
    [s appendFormat:@"INSERT INTO Transactions VALUES(%ld", (long)self.pid];
    [s appendString:@","];
    [s appendString:[self quoteSqlString:[NSString stringWithFormat:@"%ld", (long)_asset]]];
    [s appendString:@","];
    [s appendString:[self quoteSqlString:[NSString stringWithFormat:@"%ld", (long)_dstAsset]]];
    [s appendString:@","];
    [s appendString:[self quoteSqlString:[[Database instance] stringFromDate:_date]]];
    [s appendString:@","];
    [s appendString:[self quoteSqlString:[NSString stringWithFormat:@"%ld", (long)_type]]];
    [s appendString:@","];
    [s appendString:[self quoteSqlString:[NSString stringWithFormat:@"%ld", (long)_category]]];
    [s appendString:@","];
    [s appendString:[self quoteSqlString:[NSString stringWithFormat:@"%f", _value]]];
    [s appendString:@","];
    [s appendString:[self quoteSqlString:_desc]];
    [s appendString:@","];
    [s appendString:[self quoteSqlString:_memo]];
    [s appendString:@","];
    [s appendString:[self quoteSqlString:_identifier]];
    [s appendString:@");"];
}

#pragma mark Internal functions

+ (NSString *)tableName
{
    return @"Transactions";
}

@end
